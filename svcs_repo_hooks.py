#!/usr/bin/env python3
"""
Repository-Local Git Hook Manager for SVCS

This module implements git hooks for the new repository-local architecture:
1. Repository-specific hooks (not global symlinks)
2. Branch-aware semantic analysis
3. Automatic git notes sync for team collaboration
4. Integration with push/pull/merge workflows
"""

import logging
import os
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)


class RepositoryLocalHookManager:
    """Manages repository-local git hooks for SVCS."""
    
    def __init__(self, repo_path: str):
        self.repo_path = Path(repo_path).resolve()
        self.git_hooks_dir = self.repo_path / ".git" / "hooks"
        
    def install_hooks(self, hooks: List[str] = None) -> Dict[str, bool]:
        """Install SVCS hooks for this repository."""
        if hooks is None:
            hooks = ['post-commit', 'post-merge', 'post-checkout', 'pre-push']
        
        if not self.git_hooks_dir.exists():
            logger.error(f"Git hooks directory not found: {self.git_hooks_dir}")
            return {}
        
        results = {}
        for hook_name in hooks:
            results[hook_name] = self._install_hook(hook_name)
        
        return results
    
    def _install_hook(self, hook_name: str) -> bool:
        """Install a specific git hook."""
        hook_path = self.git_hooks_dir / hook_name
        
        # Generate hook content based on type
        hook_content = self._generate_hook_content(hook_name)
        
        # Check if hook already exists
        if hook_path.exists():
            # Read existing content to see if it's already SVCS-enabled
            with open(hook_path, 'r') as f:
                existing_content = f.read()
            
            if "SVCS Repository-Local Hook" in existing_content:
                logger.info(f"SVCS hook {hook_name} already installed")
                return True
            else:
                # Backup existing hook
                backup_path = hook_path.with_suffix(f"{hook_path.suffix}.backup-{int(datetime.now().timestamp())}")
                hook_path.rename(backup_path)
                logger.info(f"Backed up existing {hook_name} hook to {backup_path}")
        
        # Write new hook
        try:
            with open(hook_path, 'w') as f:
                f.write(hook_content)
            
            # Make executable
            hook_path.chmod(0o755)
            logger.info(f"Installed SVCS {hook_name} hook")
            return True
        
        except Exception as e:
            logger.error(f"Failed to install {hook_name} hook: {e}")
            return False
    
    def _generate_hook_content(self, hook_name: str) -> str:
        """Generate repository-local hook content."""
        python_path = sys.executable
        
        base_content = f'''#!/bin/bash
#
# SVCS Repository-Local Hook: {hook_name}
# Automatically generated by SVCS repository-local architecture
#

# Get the repository root
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)

if [ -z "$REPO_ROOT" ]; then
    echo "❌ SVCS: Not in a git repository"
    exit 1
fi

# Check if SVCS is initialized for this repository
if [ ! -f "$REPO_ROOT/.svcs/semantic.db" ]; then
    # SVCS not initialized for this repository, skip
    exit 0
fi

# Set PYTHONPATH to include SVCS modules
export PYTHONPATH="$REPO_ROOT:$PYTHONPATH"

'''
        
        # Add hook-specific content
        if hook_name == "post-commit":
            base_content += f'''
# Post-commit: Analyze the latest commit for semantic changes
echo "🔍 SVCS: Analyzing semantic changes..."

# Get the latest commit hash
COMMIT_HASH=$(git rev-parse HEAD)

# Run semantic analysis
{python_path} -c "
import sys
sys.path.insert(0, '$REPO_ROOT')
from svcs_repo_local import RepositoryLocalSVCS
from svcs_repo_analyzer import RepositoryLocalSemanticAnalyzer

# Initialize repository-local SVCS and analyzer
svcs = RepositoryLocalSVCS('$REPO_ROOT')
analyzer = RepositoryLocalSemanticAnalyzer('$REPO_ROOT')

# Analyze the commit
try:
    semantic_events = analyzer.analyze_commit('$COMMIT_HASH')
    if semantic_events:
        stored_count, notes_success = svcs.analyze_and_store_commit('$COMMIT_HASH', semantic_events)
        print('✅ SVCS: Stored ' + str(stored_count) + ' semantic events')
        if notes_success:
            print('📝 SVCS: Semantic data saved as git notes')
        else:
            print('⚠️ SVCS: Failed to save git notes')
    else:
        print('ℹ️ SVCS: No semantic changes detected')
except Exception as error:
    print('❌ SVCS: Analysis error: ' + str(error))
"
'''
        
        elif hook_name == "post-merge":
            base_content += f'''
# Post-merge: Sync semantic data from merged commits
echo "🔄 SVCS: Processing merge..."

# Get merge info
MERGE_HEAD=$(git rev-parse MERGE_HEAD 2>/dev/null)
HEAD=$(git rev-parse HEAD)

if [ -n "$MERGE_HEAD" ]; then
    echo "📥 SVCS: Syncing semantic data from merge"
    
    {python_path} -c "
import sys
sys.path.insert(0, '$REPO_ROOT')
from svcs_repo_local import RepositoryLocalSVCS

# Initialize repository-local SVCS
svcs = RepositoryLocalSVCS('$REPO_ROOT')

# Fetch semantic notes from merged commits
try:
    # This would implement merge semantic data integration
    print('✅ SVCS: Merge semantic data processed')
except Exception as error:
    print('❌ SVCS: Merge processing error: ' + str(error))
"
fi
'''
        
        elif hook_name == "post-checkout":
            base_content += f'''
# Post-checkout: Handle branch switching
PREV_HEAD=$1
NEW_HEAD=$2
BRANCH_SWITCH=$3

if [ "$BRANCH_SWITCH" = "1" ]; then
    echo "🌿 SVCS: Switched to branch $(git branch --show-current)"
    
    {python_path} -c "
import sys
sys.path.insert(0, '$REPO_ROOT')
from svcs_repo_local import RepositoryLocalSVCS

# Initialize repository-local SVCS
svcs = RepositoryLocalSVCS('$REPO_ROOT')

# Update branch tracking
try:
    current_branch = svcs.db.get_current_branch()
    print('📊 SVCS: Tracking semantic data for branch: ' + current_branch)
except Exception as error:
    print('❌ SVCS: Branch tracking error: ' + str(error))
"
fi
'''
        
        elif hook_name == "pre-push":
            base_content += f'''
# Pre-push: Sync semantic git notes to remote
remote="$1"
url="$2"

echo "⬆️ SVCS: Syncing semantic notes to $remote"

{python_path} -c "
import sys
sys.path.insert(0, '$REPO_ROOT')
from svcs_repo_local import RepositoryLocalSVCS

# Initialize repository-local SVCS
svcs = RepositoryLocalSVCS('$REPO_ROOT')

# Sync git notes to remote
try:
    success = svcs.git_notes.sync_notes_to_remote('$remote')
    if success:
        print('✅ SVCS: Semantic notes synced to remote')
    else:
        print('⚠️ SVCS: Note sync failed (notes may not exist)')
except Exception as error:
    print('❌ SVCS: Note sync error: ' + str(error))
"
'''
        
        base_content += '''
exit 0
'''
        
        return base_content
    
    def uninstall_hooks(self, hooks: List[str] = None) -> Dict[str, bool]:
        """Uninstall SVCS hooks from this repository."""
        if hooks is None:
            hooks = ['post-commit', 'post-merge', 'post-checkout', 'pre-push']
        
        results = {}
        for hook_name in hooks:
            hook_path = self.git_hooks_dir / hook_name
            
            if hook_path.exists():
                try:
                    # Check if it's an SVCS hook
                    with open(hook_path, 'r') as f:
                        content = f.read()
                    
                    if "SVCS Repository-Local Hook" in content:
                        hook_path.unlink()
                        results[hook_name] = True
                        logger.info(f"Uninstalled SVCS {hook_name} hook")
                    else:
                        results[hook_name] = False
                        logger.warning(f"{hook_name} hook exists but is not an SVCS hook")
                
                except Exception as e:
                    results[hook_name] = False
                    logger.error(f"Failed to uninstall {hook_name} hook: {e}")
            else:
                results[hook_name] = True  # Already uninstalled
        
        return results


class SVCSRepositoryManager:
    """High-level manager for SVCS repository operations."""
    
    def __init__(self, repo_path: str = None):
        if repo_path is None:
            repo_path = Path.cwd()
        self.repo_path = Path(repo_path).resolve()
    
    def setup_repository(self) -> str:
        """Complete SVCS setup for a repository."""
        from svcs_repo_local import RepositoryLocalSVCS
        
        # Initialize SVCS
        svcs = RepositoryLocalSVCS(self.repo_path)
        init_result = svcs.initialize_repository()
        
        if "❌" in init_result:
            return init_result
        
        # Install git hooks
        hook_manager = RepositoryLocalHookManager(self.repo_path)
        hook_results = hook_manager.install_hooks()
        
        installed_hooks = [hook for hook, success in hook_results.items() if success]
        failed_hooks = [hook for hook, success in hook_results.items() if not success]
        
        result = init_result + f"\n✅ Installed git hooks: {', '.join(installed_hooks)}"
        
        if failed_hooks:
            result += f"\n⚠️ Failed to install hooks: {', '.join(failed_hooks)}"
        
        return result
    
    def teardown_repository(self) -> str:
        """Remove SVCS from a repository."""
        # Uninstall git hooks
        hook_manager = RepositoryLocalHookManager(self.repo_path)
        hook_results = hook_manager.uninstall_hooks()
        
        uninstalled_hooks = [hook for hook, success in hook_results.items() if success]
        
        # Remove .svcs directory (but keep a backup)
        svcs_dir = self.repo_path / ".svcs"
        if svcs_dir.exists():
            backup_dir = self.repo_path / f".svcs-backup-{int(datetime.now().timestamp())}"
            svcs_dir.rename(backup_dir)
            backup_info = f"\n💾 SVCS data backed up to: {backup_dir.name}"
        else:
            backup_info = ""
        
        return f"✅ SVCS removed from repository\n✅ Uninstalled hooks: {', '.join(uninstalled_hooks)}{backup_info}"


# CLI commands for repository management
def cmd_init_repo(repo_path: str = None) -> str:
    """Initialize SVCS for a repository."""
    manager = SVCSRepositoryManager(repo_path)
    return manager.setup_repository()


def cmd_remove_repo(repo_path: str = None) -> str:
    """Remove SVCS from a repository."""
    manager = SVCSRepositoryManager(repo_path)
    return manager.teardown_repository()


def cmd_status_repo(repo_path: str = None) -> str:
    """Get SVCS status for a repository."""
    from svcs_repo_local import RepositoryLocalSVCS
    
    if repo_path is None:
        repo_path = Path.cwd()
    
    svcs = RepositoryLocalSVCS(repo_path)
    status = svcs.get_repository_status()
    
    if not status["initialized"]:
        return f"❌ SVCS not initialized for repository: {repo_path}"
    
    return f"""✅ SVCS Status for {status['repository_path']}:
📊 Current branch: {status['current_branch']}
🔢 Semantic events: {status['semantic_events_count']}
📝 Commits analyzed: {status['commits_analyzed']}
📅 Initialized: {datetime.fromtimestamp(status['created_at']).strftime('%Y-%m-%d %H:%M:%S')}"""


def demo_repository_hooks():
    """Demonstrate repository-local hook installation."""
    print("🪝 Repository-Local Git Hooks Demo")
    print("=" * 40)
    
    current_dir = Path.cwd()
    
    # Initialize repository
    result = cmd_init_repo(str(current_dir))
    print(f"🔧 Setup result:\n{result}")
    
    # Show status
    status = cmd_status_repo(str(current_dir))
    print(f"\n📊 Status:\n{status}")


if __name__ == "__main__":
    # Import here to avoid circular imports
    from datetime import datetime
    
    if len(sys.argv) > 1:
        command = sys.argv[1]
        repo_path = sys.argv[2] if len(sys.argv) > 2 else None
        
        if command == "init":
            print(cmd_init_repo(repo_path))
        elif command == "remove":
            print(cmd_remove_repo(repo_path))
        elif command == "status":
            print(cmd_status_repo(repo_path))
        else:
            print(f"Unknown command: {command}")
            print("Available commands: init, remove, status")
    else:
        demo_repository_hooks()
