#!/usr/bin/env python3
"""
Repository-Local Git Hook Manager for SVCS

This module implements git hooks for the new repository-local architecture:
1. Repository-specific hooks (not global symlinks)
2. Branch-aware semantic analysis
3. Automatic git notes sync for team collaboration
4. Integration with push/pull/merge workflows
"""

import logging
import os
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)


class RepositoryLocalHookManager:
    """Manages repository-local git hooks for SVCS."""
    
    def __init__(self, repo_path: str):
        self.repo_path = Path(repo_path).resolve()
        self.git_hooks_dir = self.repo_path / ".git" / "hooks"
        
    def install_hooks(self, hooks: List[str] = None) -> Dict[str, bool]:
        """Install SVCS hooks for this repository."""
        if hooks is None:
            hooks = ['post-commit', 'post-merge', 'post-checkout', 'pre-push']
        
        if not self.git_hooks_dir.exists():
            logger.error(f"Git hooks directory not found: {self.git_hooks_dir}")
            return {}
        
        results = {}
        for hook_name in hooks:
            results[hook_name] = self._install_hook(hook_name)
        
        return results
    
    def _install_hook(self, hook_name: str) -> bool:
        """Install a specific git hook."""
        hook_path = self.git_hooks_dir / hook_name
        
        # Generate hook content based on type
        hook_content = self._generate_hook_content(hook_name)
        
        # Check if hook already exists
        if hook_path.exists():
            # Read existing content to see if it's already SVCS-enabled
            with open(hook_path, 'r') as f:
                existing_content = f.read()
            
            if "SVCS Repository-Local Hook" in existing_content:
                logger.info(f"SVCS hook {hook_name} already installed")
                return True
            else:
                # Backup existing hook
                backup_path = hook_path.with_suffix(f"{hook_path.suffix}.backup-{int(datetime.now().timestamp())}")
                hook_path.rename(backup_path)
                logger.info(f"Backed up existing {hook_name} hook to {backup_path}")
        
        # Write new hook
        try:
            with open(hook_path, 'w') as f:
                f.write(hook_content)
            
            # Make executable
            hook_path.chmod(0o755)
            logger.info(f"Installed SVCS {hook_name} hook")
            return True
        
        except Exception as e:
            logger.error(f"Failed to install {hook_name} hook: {e}")
            return False
    
    def _generate_hook_content(self, hook_name: str) -> str:
        """Generate repository-local hook content."""
        python_path = sys.executable
        
        # Get the SVCS installation directory from environment
        svcs_install_dir = os.environ.get('SVCS_INSTALL_DIR', '')
        
        base_content = f'''#!/bin/bash
#
# SVCS Repository-Local Hook: {hook_name}
# Automatically generated by SVCS repository-local architecture
#

# Get the repository root
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)

if [ -z "$REPO_ROOT" ]; then
    echo "‚ùå SVCS: Not in a git repository"
    exit 1
fi

# Check if SVCS is initialized for this repository
if [ ! -f "$REPO_ROOT/.svcs/semantic.db" ]; then
    # SVCS not initialized for this repository, skip
    exit 0
fi

# Set PYTHONPATH to include SVCS installation and local modules
export PYTHONPATH="$REPO_ROOT/.svcs:{svcs_install_dir}:$PYTHONPATH"
export SVCS_INSTALL_DIR="{svcs_install_dir}"

'''
        
        # Add hook-specific content
        if hook_name == "post-commit":
            base_content += f'''
# Post-commit: Analyze the latest commit for semantic changes
echo "üîç SVCS: Analyzing semantic changes..."

# Get the latest commit hash
COMMIT_HASH=$(git rev-parse HEAD)

# Run semantic analysis
{python_path} -c "
import sys
import os

# Add SVCS paths to Python path
svcs_dir = os.environ.get('SVCS_INSTALL_DIR', '')
repo_svcs_dir = '$REPO_ROOT/.svcs'
if svcs_dir and svcs_dir not in sys.path:
    sys.path.insert(0, svcs_dir)
if repo_svcs_dir not in sys.path:
    sys.path.insert(0, repo_svcs_dir)

try:
    from svcs_repo_local import RepositoryLocalSVCS
    from svcs_repo_analyzer import RepositoryLocalSemanticAnalyzer

    # Initialize repository-local SVCS and analyzer
    svcs = RepositoryLocalSVCS('$REPO_ROOT')
    analyzer = RepositoryLocalSemanticAnalyzer('$REPO_ROOT')

    # Analyze the commit
    semantic_events = analyzer.analyze_commit('$COMMIT_HASH')
    if semantic_events:
        stored_count, notes_success = svcs.analyze_and_store_commit('$COMMIT_HASH', semantic_events)
        print('‚úÖ SVCS: Stored ' + str(stored_count) + ' semantic events')
        if notes_success:
            print('üìù SVCS: Semantic data saved as git notes')
        else:
            print('‚ö†Ô∏è SVCS: Failed to save git notes')
    else:
        print('‚ÑπÔ∏è SVCS: No semantic changes detected')
except Exception as error:
    print('‚ùå SVCS: Analysis error: ' + str(error))
    import traceback
    traceback.print_exc()
"
'''
        
        elif hook_name == "post-merge":
            base_content += f'''
# Post-merge: Sync semantic data from merged commits
echo "üîÑ SVCS: Processing merge..."

# Get merge info
MERGE_HEAD=$(git rev-parse MERGE_HEAD 2>/dev/null)
HEAD=$(git rev-parse HEAD)
CURRENT_BRANCH=$(git branch --show-current)

if [ -n "$MERGE_HEAD" ]; then
    echo "üì• SVCS: Syncing semantic data from merge"
    
    # Pass current branch as environment variable
    export CURRENT_BRANCH_NAME="$CURRENT_BRANCH"
    
    {python_path} -c "
import sys
import os

# Add SVCS paths to Python path
svcs_dir = os.environ.get('SVCS_INSTALL_DIR', '')
repo_svcs_dir = '$REPO_ROOT/.svcs'
if svcs_dir and svcs_dir not in sys.path:
    sys.path.insert(0, svcs_dir)
if repo_svcs_dir not in sys.path:
    sys.path.insert(0, repo_svcs_dir)

try:
    from svcs_repo_local import RepositoryLocalSVCS

    # Initialize repository-local SVCS
    svcs = RepositoryLocalSVCS('$REPO_ROOT')
    current_branch = os.environ.get('CURRENT_BRANCH_NAME', 'main')

    # Automatically process merge - find the source branch
    # This is a simplified approach - in practice you'd want more sophisticated detection
    try:
        # Get all branches that were merged
        import subprocess
        result = subprocess.run(['git', 'branch', '--merged', 'HEAD'], 
                              cwd='$REPO_ROOT', capture_output=True, text=True)
        branches = [b.strip().replace('* ', '') for b in result.stdout.split('\\n') if b.strip()]
        
        # Find non-main branches that might be the source
        source_candidates = [b for b in branches if b not in ['main', 'master', current_branch] and b != '']
        
        if source_candidates:
            source_branch = source_candidates[-1]  # Take the most recently merged
            result = svcs.process_merge(source_branch=source_branch, target_branch=current_branch)
            print('‚úÖ SVCS: ' + result)
        else:
            print('‚úÖ SVCS: Merge semantic data processed')
    except Exception as e:
        print('‚ö†Ô∏è SVCS: Could not auto-detect merge source: ' + str(e))
        print('üí° SVCS: Use \"svcs events process-merge --source-branch <SOURCE>\" manually if needed')
        
except Exception as error:
    print('‚ùå SVCS: Merge processing error: ' + str(error))
"
fi
'''
        
        elif hook_name == "post-checkout":
            base_content += f'''
# Post-checkout: Handle branch switching
PREV_HEAD=$1
NEW_HEAD=$2
BRANCH_SWITCH=$3

if [ "$BRANCH_SWITCH" = "1" ]; then
    echo "üåø SVCS: Switched to branch $(git branch --show-current)"
    
    {python_path} -c "
import sys
sys.path.insert(0, '$REPO_ROOT')
from svcs_repo_local import RepositoryLocalSVCS

# Initialize repository-local SVCS
svcs = RepositoryLocalSVCS('$REPO_ROOT')

# Update branch tracking
try:
    current_branch = svcs.db.get_current_branch()
    print('üìä SVCS: Tracking semantic data for branch: ' + current_branch)
except Exception as error:
    print('‚ùå SVCS: Branch tracking error: ' + str(error))
"
fi
'''
        
        elif hook_name == "pre-push":
            base_content += f'''
# Pre-push: Sync semantic git notes to remote
remote="$1"
url="$2"

echo "‚¨ÜÔ∏è SVCS: Syncing semantic notes to $remote"

{python_path} -c "
import sys
sys.path.insert(0, '$REPO_ROOT')
from svcs_repo_local import RepositoryLocalSVCS

# Initialize repository-local SVCS
svcs = RepositoryLocalSVCS('$REPO_ROOT')

# Sync git notes to remote
try:
    success = svcs.git_notes.sync_notes_to_remote('$remote')
    if success:
        print('‚úÖ SVCS: Semantic notes synced to remote')
    else:
        print('‚ö†Ô∏è SVCS: Note sync failed (notes may not exist)')
except Exception as error:
    print('‚ùå SVCS: Note sync error: ' + str(error))
"
'''
        
        base_content += '''
exit 0
'''
        
        return base_content
    
    def uninstall_hooks(self, hooks: List[str] = None) -> Dict[str, bool]:
        """Uninstall SVCS hooks from this repository."""
        if hooks is None:
            hooks = ['post-commit', 'post-merge', 'post-checkout', 'pre-push']
        
        results = {}
        for hook_name in hooks:
            hook_path = self.git_hooks_dir / hook_name
            
            if hook_path.exists():
                try:
                    # Check if it's an SVCS hook
                    with open(hook_path, 'r') as f:
                        content = f.read()
                    
                    if "SVCS Repository-Local Hook" in content:
                        hook_path.unlink()
                        results[hook_name] = True
                        logger.info(f"Uninstalled SVCS {hook_name} hook")
                    else:
                        results[hook_name] = False
                        logger.warning(f"{hook_name} hook exists but is not an SVCS hook")
                
                except Exception as e:
                    results[hook_name] = False
                    logger.error(f"Failed to uninstall {hook_name} hook: {e}")
            else:
                results[hook_name] = True  # Already uninstalled
        
        return results


class SVCSRepositoryManager:
    """High-level manager for SVCS repository operations."""
    
    def __init__(self, repo_path: str = None):
        if repo_path is None:
            repo_path = Path.cwd()
        self.repo_path = Path(repo_path).resolve()
    
    def setup_repository(self) -> str:
        """Complete SVCS setup for a repository."""
        from svcs_repo_local import RepositoryLocalSVCS
        
        # Check if SVCS is already initialized
        svcs_db_path = self.repo_path / ".svcs" / "semantic.db"
        is_new_init = not svcs_db_path.exists()
        
        # Initialize SVCS
        svcs = RepositoryLocalSVCS(self.repo_path)
        init_result = svcs.initialize_repository()
        
        if "‚ùå" in init_result:
            return init_result
        
        # If this is a new initialization, try to fetch remote semantic notes
        if is_new_init:
            notes_result = self._fetch_remote_notes()
            if notes_result:
                init_result += f"\n{notes_result}"
        
        # Install git hooks
        hook_manager = RepositoryLocalHookManager(self.repo_path)
        hook_results = hook_manager.install_hooks()
        
        installed_hooks = [hook for hook, success in hook_results.items() if success]
        failed_hooks = [hook for hook, success in hook_results.items() if not success]
        
        result = init_result + f"\n‚úÖ Installed git hooks: {', '.join(installed_hooks)}"
        
        if failed_hooks:
            result += f"\n‚ö†Ô∏è Failed to install hooks: {', '.join(failed_hooks)}"
        
        return result
    
    def _fetch_remote_notes(self) -> str:
        """Fetch remote semantic notes if available."""
        try:
            # Check if remote exists
            remotes_result = subprocess.run(
                ["git", "remote"],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=False
            )
            
            if remotes_result.returncode != 0 or not remotes_result.stdout.strip():
                return ""  # No remotes configured
            
            remotes = remotes_result.stdout.strip().splitlines()
            if "origin" not in remotes:
                return ""  # No origin remote
            
            # Try to fetch semantic notes from origin
            fetch_result = subprocess.run(
                ["git", "fetch", "origin", "refs/notes/svcs-semantic:refs/notes/svcs-semantic"],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=False
            )
            
            if fetch_result.returncode == 0:
                # Notes fetched successfully, now import them to database
                from svcs_repo_local import RepositoryLocalSVCS
                svcs = RepositoryLocalSVCS(self.repo_path)
                
                # Get all commits with notes and import their semantic data
                notes_commits_result = subprocess.run(
                    ["git", "notes", "--ref=svcs-semantic", "list"],
                    cwd=self.repo_path,
                    capture_output=True,
                    text=True,
                    check=False
                )
                
                if notes_commits_result.returncode == 0 and notes_commits_result.stdout.strip():
                    commits_with_notes = []
                    for line in notes_commits_result.stdout.strip().splitlines():
                        if line.strip():
                            commit_hash = line.split()[1] if len(line.split()) > 1 else line.strip()
                            commits_with_notes.append(commit_hash)
                    
                    imported_count = 0
                    for commit_hash in commits_with_notes:
                        semantic_data = svcs.git_notes.get_semantic_data_from_note(commit_hash)
                        if semantic_data and "semantic_events" in semantic_data:
                            stored_count, _ = svcs.analyze_and_store_commit(
                                commit_hash, semantic_data["semantic_events"]
                            )
                            imported_count += stored_count
                    
                    if imported_count > 0:
                        return f"üîÑ Fetched remote semantic notes and imported {imported_count} events"
                    else:
                        return "üîÑ Fetched remote semantic notes (no events to import)"
                else:
                    return "üîÑ Fetched remote semantic notes (empty)"
            else:
                # Notes fetch failed (likely no notes exist on remote)
                return ""
        
        except Exception as e:
            logger.warning(f"Failed to fetch remote notes: {e}")
            return ""
    
    def teardown_repository(self) -> str:
        """Remove SVCS from a repository."""
        # Uninstall git hooks
        hook_manager = RepositoryLocalHookManager(self.repo_path)
        hook_results = hook_manager.uninstall_hooks()
        
        uninstalled_hooks = [hook for hook, success in hook_results.items() if success]
        
        # Remove .svcs directory (but keep a backup)
        svcs_dir = self.repo_path / ".svcs"
        if svcs_dir.exists():
            backup_dir = self.repo_path / f".svcs-backup-{int(datetime.now().timestamp())}"
            svcs_dir.rename(backup_dir)
            backup_info = f"\nüíæ SVCS data backed up to: {backup_dir.name}"
        else:
            backup_info = ""
        
        return f"‚úÖ SVCS removed from repository\n‚úÖ Uninstalled hooks: {', '.join(uninstalled_hooks)}{backup_info}"


# CLI commands for repository management
def cmd_init_repo(repo_path: str = None) -> str:
    """Initialize SVCS for a repository."""
    manager = SVCSRepositoryManager(repo_path)
    return manager.setup_repository()


def cmd_remove_repo(repo_path: str = None) -> str:
    """Remove SVCS from a repository."""
    manager = SVCSRepositoryManager(repo_path)
    return manager.teardown_repository()


def cmd_status_repo(repo_path: str = None) -> str:
    """Get SVCS status for a repository."""
    from svcs_repo_local import RepositoryLocalSVCS
    
    if repo_path is None:
        repo_path = Path.cwd()
    
    svcs = RepositoryLocalSVCS(repo_path)
    status = svcs.get_repository_status()
    
    if not status["initialized"]:
        return f"‚ùå SVCS not initialized for repository: {repo_path}"
    
    return f"""‚úÖ SVCS Status for {status['repository_path']}:
üìä Current branch: {status['current_branch']}
üî¢ Semantic events: {status['semantic_events_count']}
üìù Commits analyzed: {status['commits_analyzed']}
üìÖ Initialized: {datetime.fromtimestamp(status['created_at']).strftime('%Y-%m-%d %H:%M:%S')}"""


def demo_repository_hooks():
    """Demonstrate repository-local hook installation."""
    print("ü™ù Repository-Local Git Hooks Demo")
    print("=" * 40)
    
    current_dir = Path.cwd()
    
    # Initialize repository
    result = cmd_init_repo(str(current_dir))
    print(f"üîß Setup result:\n{result}")
    
    # Show status
    status = cmd_status_repo(str(current_dir))
    print(f"\nüìä Status:\n{status}")


if __name__ == "__main__":
    # Import here to avoid circular imports
    from datetime import datetime
    
    if len(sys.argv) > 1:
        command = sys.argv[1]
        repo_path = sys.argv[2] if len(sys.argv) > 2 else None
        
        if command == "init":
            print(cmd_init_repo(repo_path))
        elif command == "remove":
            print(cmd_remove_repo(repo_path))
        elif command == "status":
            print(cmd_status_repo(repo_path))
        else:
            print(f"Unknown command: {command}")
            print("Available commands: init, remove, status")
    else:
        demo_repository_hooks()
